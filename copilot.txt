
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"

    "github.com/Shopify/sarama"
)

type consumerGroupHandler struct{}

// Setup is run at the beginning of a new session, before ConsumeClaim
func (consumerGroupHandler) Setup(s sarama.ConsumerGroupSession) error { return nil }

// Cleanup is run at the end of a session, once all ConsumeClaim goroutines have exited
func (consumerGroupHandler) Cleanup(s sarama.ConsumerGroupSession) error { return nil }

// ConsumeClaim starts a consumer loop of the given claim (partition)
// Must run the loop and return only when claim.Messages() channel is closed
func (consumerGroupHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for msg := range claim.Messages() {
        log.Printf("Message: topic=%s partition=%d offset=%d key=%s value=%s",
            msg.Topic, msg.Partition, msg.Offset, string(msg.Key), string(msg.Value))

        // Mark message consumed for commit
        sess.MarkMessage(msg, "")
    }
    return nil
}

func main() {
    brokers := []string{"localhost:9092"}
    groupID := "my-consumer-group"
    topics := []string{"test-topic"}

    config := sarama.NewConfig()
    config.Version = sarama.V2_6_0_0           // adjust to match your Kafka cluster version
    config.Consumer.Group.Rebalance.Strategy = sarama.BalanceStrategyRange
    config.Consumer.Offsets.Initial = sarama.OffsetNewest // or sarama.OffsetOldest
    config.Consumer.Return.Errors = true

    // For stable consumer offsets commits:
    config.Consumer.Group.Session.Timeout = 10 * 1000 // ms
    config.Consumer.Group.Heartbeat.Interval = 3 * 1000 // ms

    // Create consumer group
    cg, err := sarama.NewConsumerGroup(brokers, groupID, config)
    if err != nil {
        log.Fatalf("Error creating consumer group: %v", err)
    }
    defer cg.Close()

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // Handle signals for graceful shutdown
    go func() {
        sigchan := make(chan os.Signal, 1)
        signal.Notify(sigchan, syscall.SIGINT, syscall.SIGTERM)
        <-sigchan
        log.Println("Shutdown signal received")
        cancel()
    }()

    handler := consumerGroupHandler{}

    // Consume in a loop to handle rebalances and errors
    for {
        if err := cg.Consume(ctx, topics, handler); err != nil {
            log.Printf("Error from consumer: %v", err)
        }
        // If context was cancelled, exit loop
        if ctx.Err() != nil {
            break
        }
    }

    log.Println("Consumer group closed")
}

// SASL/SSL (if your cluster is secured):
config.Net.SASL.Enable = true
config.Net.SASL.Mechanism = sarama.SASLTypePlaintext // or OAUTHBEARER, SCRAM
config.Net.SASL.User = "username"
config.Net.SASL.Password = "password"

config.Net.TLS.Enable = true
// Optionally set config.Net.TLS.Config = &tls.Config{...} for custom CA/cert
